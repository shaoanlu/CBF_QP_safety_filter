import numpy as np
from scipy.special import logsumexp

import osqp

# import proxsuite
from typing import Optional, List, Tuple

from models.i_model import ModelInterface
from controllers.i_controller import ControllerInterface
from controllers.components.cbfqp_problem import CBFQPFormulation

from controllers.components.disturbance_observer import (
    BasicDisturbanceObserver,
    DisturbanceObserver,
    CautionAdamDisturbanceObserver,
)


# IDs for detecting arrow keypress in PyGame
K_LEFT = 1073741904
K_RIGHT = 1073741903
K_UP = 1073741906
K_DOWN = 1073741905


class RobotCBF(ControllerInterface):
    def __init__(
        self,
        model: ModelInterface,
        color: tuple = (0, 0, 255),
        vel: float = 3,
        size: int = 30,
    ):
        """
        A controller for a robot using Control Barrier Functions (CBF) as
        a safety filter for collision prevention. The CBF modifies user commands
        ensuring safety without significantly deviating from the intended movement.
        """
        self.model = model
        self.ux = 0  # actual control input
        self.uy = 0  # actual control input
        self.nominal_ux = 0  # user control input
        self.nominal_uy = 0  # user control input
        self.color = color  # color of the robot in PyGame GUI
        self.vel = vel  # robot velocity generated by use control input
        self.size = size
        self.is_collided = False
        self.prob = None
        self.nx = 2  # x and y control

        self.prev_h = None
        # self.disturbance_observer = DisturbanceObserver(CautionAdamDisturbanceObserver(lr=1.0))
        self.disturbance_observer = DisturbanceObserver(BasicDisturbanceObserver(gain=1.0))
        self.disturbance = 0.0

    @property
    def x(self):
        return self.model.x[0]

    @property
    def y(self):
        return self.model.x[1]

    @x.setter
    def x(self, value):
        self.model.x[0] = value

    @y.setter
    def y(self, value):
        self.model.x[1] = value

    def control(
        self,
        key: Optional[int] = None,
        use_cbf: bool = False,
        force_direction_unchanged: bool = False,  # whether to allow safety filter to change direction of user input
        cbf_alpha: float = 1e-1,
        penalty_slack: float = 10,
        collision_objects: list = [],
        is_lidar_simulation: bool = True,
    ):
        """
        Processes control inputs, applies CBF for safety if enabled, and updates the robot's position.
        """
        self.nominal_ux, self.nominal_uy = 0, 0

        # get user command
        self._update_nominal_control(key)

        # get cbf filtered command
        if use_cbf:
            self._apply_cbf_safe_control(
                self.nominal_ux,
                self.nominal_uy,
                cbf_alpha,
                penalty_slack,
                force_direction_unchanged,
                collision_objects,
                is_lidar_simulation,
            )
        else:
            self._apply_nominal_control()

        # update xy positions based on derived command
        self._update_positions(self.ux, self.uy)

    def _apply_nominal_control(self):
        """
        Applies nominal control inputs (user inputs) directly to the robot without safety adjustments.
        """
        self.ux, self.uy = self.nominal_ux, self.nominal_uy

    def _update_positions(self, ux: float, uy: float):
        model_control = np.array([ux, uy])
        self.model.forward(model_control)

    def _update_nominal_control(self, key: int):
        """
        Updates nominal control inputs based on user key input.
        """
        ux, uy = 0, 0
        if key is not None:
            if key == K_LEFT:
                ux = -self.vel
            elif key == K_RIGHT:
                ux = self.vel
            elif key == K_UP:
                uy = -self.vel
            elif key == K_DOWN:
                uy = self.vel
        self.nominal_ux, self.nominal_uy = ux, uy

    def _apply_cbf_safe_control(
        self,
        ux: float,
        uy: float,
        cbf_alpha: float,
        penalty_slack: float,
        force_direction_unchanged: bool,
        collision_objects: list,
        is_lidar_simulation: bool = False,
    ):
        # Calculate barrier values and coeffs in h_dot
        if not is_lidar_simulation:
            nh = len(collision_objects)  # number of cbf constraint
            h, coeffs_dhdx = self._calculate_h_and_coeffs_dhdx(collision_objects)
            disturbance = [0] * len(collision_objects)
        else:
            nh = 1  # compoosing cbf constraints into one
            h, coeffs_dhdx = self._calculate_composite_h_and_coeffs_dhdx(collision_objects)

            # D.O. is implemented for the composite CBF where there is only one CBF constraint
            disturbance = self._estimate_disturbance(h=h, coeffs_dhdx=coeffs_dhdx)
            disturbance = [disturbance] * nh

        # Solve CBF-QP
        control = np.array([ux, uy])
        control_bounds = self._get_control_bounds(force_direction_unchanged)
        ux, uy = self._solve_cbf_qp(
            h=h,
            coeffs_dhdx=coeffs_dhdx,
            disturbance_h_dot=disturbance,
            control=control,
            control_bounds=control_bounds,
            cbf_alpha=cbf_alpha,
            penalty_slack=penalty_slack,
        )

        # Handle infeasible sol.
        ux = self.nominal_ux if ux is None else ux
        uy = self.nominal_uy if uy is None else uy

        self.ux, self.uy = ux, uy

    def _calculate_h_and_coeffs_dhdx(self, collision_objects: list):
        h = []  # barrier values (here, remaining distance to each obstacle)
        coeffs_dhdx = []  # dhdt = dhdx * dxdt = dhdx * u
        for obj in collision_objects:
            model_state = [self.x, self.y]
            self.model.update_params({"xr": obj.x, "yr": obj.y, "size": self.size})
            h.append(self.model.h(model_state))
            # Note: append additional elements for the slack variable Î´
            coeffs_dhdx.append(self.model.h_dot(model_state) + [1] * len(collision_objects))
        return h, coeffs_dhdx

    def _calculate_composite_h_and_coeffs_dhdx(self, collision_objects: list) -> Tuple[List[float], List[List[float]]]:
        if len(collision_objects) == 0:
            return [1], [[0, 0, 1]]

        kappa, dist_buffer = 5e-3, self.size * 1.3
        x0 = np.array([self.x, self.y])
        lidar_points = np.array(collision_objects)
        hi_x = np.linalg.norm(x0 - lidar_points, axis=1) ** 2 - dist_buffer**2
        assert hi_x.shape == (len(lidar_points),), hi_x
        h_x = -1 / kappa * logsumexp(-kappa * hi_x)  # beware of numerical error due to exponent
        dhdx = np.sum(np.exp(-kappa * (hi_x - h_x))[..., None] * (-2 * lidar_points + 2 * x0), axis=0)
        # gamma = 1
        # vi_x = np.tanh(hi_x / gamma)
        # h_x = -gamma / kappa * logsumexp(-kappa * vi_x)  # scale to prevent numerical error
        # dhdx = np.sum(
        #     (np.exp(-kappa * (vi_x - h_x)) / (np.cosh(hi_x / gamma) ** 2))[..., None] * 2 * (x0 - lidar_points),
        #     axis=0,
        # )  # this drivative is buggy
        assert dhdx.shape == (2,), dhdx
        return [h_x], [[dhdx[0], dhdx[1], 1]]

    def _estimate_disturbance(
        self,
        h: List[float],
        coeffs_dhdx: List[List[float]],
        **kwargs,
    ) -> float:
        model_state = np.array([self.x, self.y])
        model_control = np.array([self.ux, self.uy])
        disturbance = self.disturbance_observer.update(
            h=h,
            coeffs_dhdx=coeffs_dhdx,
            control=model_control,
            f_x=self.model.f_x(model_state),
            g_x=self.model.g_x(model_state),
            velocity=self.vel,
        )
        return disturbance

    def _get_control_bounds(self, force_direction_unchanged: bool) -> Tuple[np.ndarray, np.ndarray]:
        max_control = (
            np.array([np.maximum(self.ux, 0), np.maximum(self.uy, 0)])
            if force_direction_unchanged
            else np.array([self.vel, self.vel])
        )
        min_control = (
            np.array([np.minimum(self.ux, 0), np.minimum(self.uy, 0)])
            if force_direction_unchanged
            else np.array([-self.vel, -self.vel])
        )
        return max_control, min_control

    def _solve_cbf_qp(
        self,
        h: List[float],
        coeffs_dhdx: List[List[float]],
        disturbance_h_dot: List[float],
        control: np.ndarray,
        control_bounds: Tuple[np.ndarray, np.ndarray],
        cbf_alpha: float,
        penalty_slack: float,
    ) -> Optional[np.ndarray]:
        max_control, min_control = control_bounds
        qp_formulation = CBFQPFormulation(nx=self.nx, nh=len(h))
        qp_data = qp_formulation.create_matrices(
            h=h,
            coeffs_dhdx=coeffs_dhdx,
            nominal_control=control,
            max_control=max_control,
            min_control=min_control,
            cbf_alpha=cbf_alpha,
            slack_penalty=penalty_slack,
            disturbance_h_dot=disturbance_h_dot,
        )
        P, q, A, l, u = qp_data.P, qp_data.q, qp_data.A, qp_data.l, qp_data.u

        # Solve QP problem
        self.prob = osqp.OSQP()
        self.prob.setup(P, q, A, l, u, verbose=False, time_limit=0)
        res = self.prob.solve()
        # res = proxsuite.proxqp.dense.solve(H=P.toarray(), g=q, C=A.toarray(), l=l, u=u)
        ux, uy = res.x[: self.nx]
        return ux, uy

    def detect_collision(self, collision_objects: list = []):
        """
        Loop through all objects (robots) and set self.is_collides as True
        if distance to any specified robot being smaller than 2*self.size
        """
        self.is_collided = False
        if len(collision_objects) > 0:
            for obj in collision_objects:
                dist = np.linalg.norm(np.array([self.x, self.y] - np.array([obj.x, obj.y])))
                if dist <= (self.size * 2):
                    self.is_collided = True
